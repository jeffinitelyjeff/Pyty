Basic Architecture
==================
-src/
  -parser_helper.py <-- helper functions for leading, traversing AST.
  -typer.py <-- meat of the program, checks typing.
  -test/
    -parser_helper_tests.py <-- unit testing of methods of parser_helper.
    -basic_tests.py <-- unit testing of typechecking basic operations.
    -basic_file.py <-- source code file to use for basic_tests.py


Basic Flow
==========
Epydoc parsing will be used to build up an initial type environment (env0)
mapping variable and function names to types defined in user comments. The rest
of typing procedure will then utilize ASTs. Each AST node will be assigned a
unique ID (probably stored in the AST data structure?), and then env0 will be
converted to an environment mapping AST node IDs to types. A list (to_check) 
of all AST node IDs will be constructed; every time an AST node is successfully
typechecked, its ID will be removed from to_check. Nodes which already have
types defined in env0 will eventually be typechecked to confirm they actually
have the specified type, so at any point before that they can be assumed to
have the specified type. In order to typecheck a program, does_typecheck()
will be run on the entire file, with environment env0. Every time the type
for an AST node is determined, that information will be added to the
running environment (ie, the environmetn which is then passed along to further
recursive calls of typecheck()).


Goals for First Run
===================
Create typechecking system for small subset of Python language (ie, numbers,
bools, binary ops, control flow), chosen as a subset of Python's Abstract 
Syntax Tree's abstract grammar. Types will be defined in epydoc docstrings, and
the PyTy type checker will use epydoc to parse the docstrings and look for
apporpriate type definitions for every variable instantiated.


Current Goal for Type Hierarchy
===============================

Note: There seems to be considerable (and confusing) difference between th
edocumentation on ASTs and the actual module, so the following specification
will be taken loosely. For instance, in the AST documentation it mentions that
there are 5 builtin types (identifiers, int, string, object, bool), but there
does not seem to be any way to trace in the documentation how an expr is ever
classified as an int, string, or bool. Also, there seems to be no mention of
any type for module when actually querying AST objects; the AST is just
stored as a list of statements. I'm not sure at this point whether this is
going to cause any issues down the road.

mod
---
- Module(stmt* body)

stmt
----
- Assign(expr* targets, expr value)
- Expr(expr value)

expr
----
- BoolOp(boolop op, expr* values)
- BinOp(expr left, operator op, expr right)

boolop
------
- And
- Or

operator
--------
- Add
- Sub
- Mult
- Div
- Mod

Old Goal for Type Hierarchy
===========================

stmt
----
- For(expr target, expr iter, stmt* body, stmt* orelse)
- While(expr test, stmt* body, stmt* orelse)
- If(expr test, stmt* body, stmt* orelse)
- Expr(expr value)

expr
----
- BoolOp(boolop op, expr* values)
- BinOp(expr left, operator op, expr right)
- UnaryOp(unaryop op, expr operand)
- IfExp(expr test, expr body, expr orelse)
- Repr(expr value)
- Int(object n)
- True
- False

boolop
------
- And
- Or

operator
--------
- Add
- Sub
- Mult
- Div
- Mod

unaryop
-------
- Invert
- Not
- Uadd (this is like in x = +5)
- Usub (this is like in x = -5)


Typechecking "Rules"
====================

- BinOp(expr left, operator op, expr right) typechecks as an expr if left,
  op, and right have their correct types.
- BoolOp(boolop op, expr* values) typechecks as an expr if op and values have
  their correct types. 
- Seems really basic and self-explanatory from the AST definitions...

Important Links
===============
Python Abstract Syntax Tree Module - http://docs.python.org/library/ast.html
Epydoc Epytext Parser - http://epydoc.sourceforge.net/api/epydoc.markup.epytext-module.html



