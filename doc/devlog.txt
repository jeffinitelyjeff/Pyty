10-19-2010
==========
Looked more into how assignments are managed in an AST. Started trying to
generate a list of all variables assigned values, so I can eventually use that
list to look in the docstrings to gather type information to check against.
Docstrings that aren't available from the AST module shouldn't be hard to find,
since I'll have access to line numbers. Not at a stage to test yet, still trying
to get basic functions running (after which I'll make tests). Having lots of
trouble parsing files in other directories: Python keeps throwing
"AttributeError: 'module' object has no attribute 'suite" from code in the
compiler class.

10-21-2010
==========
When trying to write unit tests for the typechecking rules, starting to run into
the issue of not really knowing how the program is going to be organized -- what
kind of interface should the program have for the unit testing to call upon?
Interface is something I hadn't thought about until now; might have to ask
Danner for help with where to start.
How will type information be stored? When I check whether an invert expression
typechecks, it can't just refer to the AST for its expr argument and recurse 
down until it can determine its type; that would be type inference, not type
checking. I need to store some kind of parsing information -- like, "I've looked
at these variables and determined that they are this type." I think I can
achieve this by simply adding a "type" instance variable to each node object.
But then where does this fit in to unit testing? My idea is this: have a parse
function which takes an AST and inserts type information into it, then each unit
test could just call the parse function on the node it's interested in (so the
invert unit test would call it on the AST subtree beginning at the invert node);
but then wouldn't every unit test become an almost trivial 
assertTrue(parse(...)) or assertFalse(parse(...)), assuming parse returns a
boolean representing if it typechecked successfully? Maybe that isn't a problem. 

11-3-2010
=========
- Suffering grave consequences from taking time off from working on this 
  project. Have forgotten some details from my discussion with Danner on 10/22.
  I remember there was some discussion about what types an environment 
  dictionary should store; for now, I'm going to naively assume both variable 
  names and type names should be stored as strings, though I recall there was 
  some discussion about type names possibly being stored as an enumerated type
  or some class structure. I envision this won't be terribly detrimental until
  I start to consider subtyping.
- I am also afraid that we talked about the typechecking function having 3
  parameters, not 2, and am afraid I'm forgetting something...
- Just realized that typecheck() should possbily return an environment, not a
  boolean, assuming it typechecks properly, and should throw a DoesNotTypecheck
  error if it doesn't typecheck. that way typecheck() itself could be used to build up
  the environment.

11-4-2010
=========
- Decided to make typecheck() return a type value, and then will make a helper
  function which adds that type to the environment dictionary.
- Unsure about whether to make two different error cases for whether the
  incorrect typing occurs at the root node for the AST or in some subtree.
  Actually, that can be stored as data in the DoesNotTypecheck exception.
* Wondering whether environments can change with time, and how that would
  complicate things... It seems like something I should consider, but also
  something that would only arise due to bad practice (using a variable for one
  type in one place, and then for another type in another place). Then again,
  it should arise whenever using looping or local dummy variables, so it does
  seem like a real issue. Now wondering how to handle that... I think it is
  handled implicitly by passing around an environment which is morphed with
  each call of typecheck, since it seems like there should be a unique
  environment for each AST node, but then there are issues of backtracking and
  removing elements from the environment...
  
